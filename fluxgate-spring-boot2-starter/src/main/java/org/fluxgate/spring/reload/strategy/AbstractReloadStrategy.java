package org.fluxgate.spring.reload.strategy;

import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicBoolean;
import org.fluxgate.core.reload.ReloadSource;
import org.fluxgate.core.reload.RuleReloadEvent;
import org.fluxgate.core.reload.RuleReloadListener;
import org.fluxgate.core.reload.RuleReloadStrategy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Abstract base class for reload strategies.
 *
 * <p>Provides common functionality for managing listeners and lifecycle state.
 */
public abstract class AbstractReloadStrategy implements RuleReloadStrategy {

  protected final Logger log = LoggerFactory.getLogger(getClass());

  private final List<RuleReloadListener> listeners = new CopyOnWriteArrayList<>();
  private final AtomicBoolean running = new AtomicBoolean(false);

  /** The reload source for events generated by this strategy. */
  protected abstract ReloadSource getReloadSource();

  @Override
  public void start() {
    if (running.compareAndSet(false, true)) {
      log.info("Starting {} reload strategy", getClass().getSimpleName());
      doStart();
    } else {
      log.debug("{} reload strategy already running", getClass().getSimpleName());
    }
  }

  @Override
  public void stop() {
    if (running.compareAndSet(true, false)) {
      log.info("Stopping {} reload strategy", getClass().getSimpleName());
      doStop();
    } else {
      log.debug("{} reload strategy already stopped", getClass().getSimpleName());
    }
  }

  @Override
  public boolean isRunning() {
    return running.get();
  }

  @Override
  public void triggerReload(String ruleSetId) {
    Objects.requireNonNull(ruleSetId, "ruleSetId must not be null");
    log.debug("Triggering reload for ruleSetId: {}", ruleSetId);
    notifyListeners(RuleReloadEvent.forRuleSet(ruleSetId, ReloadSource.MANUAL));
  }

  @Override
  public void triggerReloadAll() {
    log.debug("Triggering full reload");
    notifyListeners(RuleReloadEvent.fullReload(ReloadSource.MANUAL));
  }

  @Override
  public void addListener(RuleReloadListener listener) {
    Objects.requireNonNull(listener, "listener must not be null");
    listeners.add(listener);
    log.debug("Added reload listener: {}", listener.getClass().getSimpleName());
  }

  @Override
  public void removeListener(RuleReloadListener listener) {
    Objects.requireNonNull(listener, "listener must not be null");
    listeners.remove(listener);
    log.debug("Removed reload listener: {}", listener.getClass().getSimpleName());
  }

  /**
   * Notifies all registered listeners of a reload event.
   *
   * @param event the reload event
   */
  protected void notifyListeners(RuleReloadEvent event) {
    if (listeners.isEmpty()) {
      log.trace("No listeners registered, skipping notification");
      return;
    }

    log.debug("Notifying {} listeners of reload event: {}", listeners.size(), event);

    for (RuleReloadListener listener : listeners) {
      try {
        listener.onReload(event);
      } catch (Exception e) {
        log.error("Error notifying listener {} of reload event", listener.getClass().getName(), e);
      }
    }
  }

  /** Called when the strategy is started. Subclasses should implement their startup logic here. */
  protected abstract void doStart();

  /** Called when the strategy is stopped. Subclasses should implement their cleanup logic here. */
  protected abstract void doStop();

  /**
   * Returns the number of registered listeners.
   *
   * @return listener count
   */
  protected int getListenerCount() {
    return listeners.size();
  }
}
